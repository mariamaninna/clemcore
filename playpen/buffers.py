from typing import List, Dict, Any, Protocol
from datasets import Dataset

from clemcore.backends import Model

from playpen.branching.tree import GameTree, ResponseTreeNode


class PreferenceLike(Protocol):

    def to_preference_dataset(self, perspective: Model, data_format="conversational") -> Dataset:
        """
        Transform the rollout buffer to a preference dataset for, e.g., DPO learning.

        # Standard format
        preference_example = {"prompt": "The sky is", "chosen": " blue.", "rejected": " green."}

        # Conversational format
        preference_example = {"prompt": [{"role": "user", "content": "What color is the sky?"}],
                              "chosen": [{"role": "assistant", "content": "It is blue."}],
                              "rejected": [{"role": "assistant", "content": "It is green."}]}

        :param perspective: of a model generating the responses
        :param data_format: conversational or standard
        :return: a preference dataset as described in https://huggingface.co/docs/trl/dataset_formats#preference
        """
        return Dataset.from_list([])


class ConversationLike(Protocol):

    def to_conversational_dataset(self, perspective: Model) -> Dataset:
        """
        Converts the data collected in the buffer into a dataset where each row represents a conversation.

        A conversation is basically a dict where the "messages" entry points to a list of dicts where each
        of these contain alternating entries of "role" (assistant or user) and "content" depending on the perspective.
        For example:

        {"messages" = [
            {"role": "user", "content": "Hello, how are you?"},\n
            {"role": "assistant", "content": "I'm doing great. How can I help you today?"},\n
            {"role": "user", "content": "I'd like to show off how chat templating works!"}\n
            ]}

        See also https://huggingface.co/docs/trl/dataset_formats#conversational
        Args:
            perspective: to take in the dataset as specified by the given model
        Returns: the Dataset
        """
        return Dataset.from_list([])


class EpisodeBuffer(ConversationLike):
    """ Buffer to collect the full episode trajectories generated by a session of game play"""

    def __init__(self):
        self.episodes: List[List[Dict[str, Any]]] = [[]]
        self.current_episode: int = 0

    def add_step(self, context, response, done, info):
        """Append a step to the current episode."""
        self.episodes[self.current_episode].append({
            "context": context,
            "response": response,
            "done": done,
            "info": info
        })

    def next_episode(self):
        if self.episodes[self.current_episode]:  # only if current episode not empty
            self.episodes.append([])
            self.current_episode += 1

    def reset(self):
        """Clear all stored episodes."""
        self.episodes: List[List[Dict[str, Any]]] = [[]]
        self.current_episode: int = 0

    def __iter__(self):
        return iter(self.episodes)


class BranchingEpisodeBuffer(ConversationLike, PreferenceLike):
    """ Buffer to collect multiple full episode trajectories generated by a session of game play with branching """

    def __init__(self):
        self.forest: List[GameTree] = []

    def add_episode_tree(self, episode_tree: GameTree):
        self.forest.append(episode_tree)

    def reset(self):
        self.forest = []

    def to_conversational_dataset(self, perspective: Model) -> Dataset:
        def recursive_add_to(_messages: List[Dict], node: ResponseTreeNode):
            # only collect for given conversational perspective
            if perspective is node.player.model:
                # we reverse later
                _messages.append(dict(role="assistant", content=node.response))
                _messages.append(node.context)
            if isinstance(node.parent, ResponseTreeNode):
                recursive_add_to(_messages, node.parent)
            return _messages

        dataset = []
        for active_tree in self.forest:
            for leave in active_tree.find_leaves():
                messages = recursive_add_to([], leave)
                messages.reverse()
                dataset.append(dict(messages=messages, reward=leave.info["episode_score"]))
        return Dataset.from_list(dataset)
